unit xmledit.main;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, xmldom, XMLIntf, msxmldom, XMLDoc, ComCtrls, StdCtrls

  ,Generics.Collections
  ,ExtCtrls
  ,lp.lexer, lp.token, lp.parser, lp.evaluator
  ;


type
  TForm6 = class(TForm)
    TreeView1: TTreeView;
    XMLProps: TXMLDocument;
    Panel1: TPanel;
    Button1: TButton;
    Button2: TButton;
    List: TListBox;
    Panel2: TPanel;
    Memo1: TMemo;
    MSouce: TMemo;
    Button3: TButton;
    procedure FormCreate(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
  private
    { Private declarations }
    procedure Describe(node: TASTNode; SParent:TTreeNode);
  public
    { Public declarations }
  end;

  TPreprocessorNodeType = (pntText, pntIf, pntEndIF, pntQry);

  TPreprocessorNode = class
    NType:TPreprocessorNodeType;
    Param:string;
    Body:string;
    Childs: TObjectList<TPreprocessorNode>;
  public
    constructor Create(ANodeType:TPreprocessorNodeType; AParam:string; ABoby: string);
    destructor Destroy; override;
  end;

const
  PreprocessorNodeTypeStr: Array[TPreprocessorNodeType] of string = ('NTEXT','NIF','NIFEND','NQR');

var
  Form6: TForm6;


implementation

{$R *.dfm}

// -- preprocessor xml --

// <|§ IF(D|DTIPRE|=|D D|DCODAR|>|0 D|DPREZZ|>|0) §|>

// <|§ ENDIF §|>
// <|§ QR() §|>

function StrSplit(var S:String; C:Char):string;
var
  P:Integer;
  R:String;
begin
  P:=Pos(C,S);
  if P=0 then
  begin
    R:=S;
    S:='';
  end
  else
  begin
    R:=Copy(S,1,P-1);
    S:=Copy(S,P+1,length(S)-P);
  end;
  Result:=R;
end;


function StrSplitPlus(var S:String; C:string):string;
var
  P:Integer;
  R:String;
begin
  P:=Pos(C,S);
  if P=0 then
  begin
    R:=S;
    S:='';
  end
  else
  begin
    R:=Copy(S,1,P-1);
    S:=Copy(S,P+length(C),length(S)-P);
  end;
  Result:=R;
end;


function ParsePrePorcessor(SBody:string):TPreprocessorNode;

  function ParseFunctions(var Body:string):TPreprocessorNode;
  var
    S1,S2:string;
    F,P:string;
    N:TPreprocessorNode;
  begin
    Result := TPreprocessorNode.Create(pntText,'','');
    if (Trim(Body)<>'') then
    begin
      if Pos('<|§',Body)>0 then
      begin
        S1 := StrSplitPlus(Body,'<|§');
        S2 := StrSplitPlus(Body,'§|>');

        if (S1<>'') then
          Result.Childs.Add(TPreprocessorNode.Create(pntText,'',S1));

        F:= Trim(UpperCase(StrSplit(S2,'(')));
        P:= Trim(StrSplit(S2,')'));
        if F='IF' then
        begin
          N:=TPreprocessorNode.Create(pntIf,P,'');
          N.Childs.Add(ParseFunctions(Body));
          Result.Childs.Add(N);
        end
        else
        if F='QR' then
        begin
          N:=TPreprocessorNode.Create(pntQry,P,'');
          Result.Childs.Add(N);
        end
        else
        if F='ENDIF' then
        begin
          //Result.NType := pntEndIF;
        end;

        if ((Trim(Body)<>'') and (F<>'ENDIF')) then
          Result.Childs.Add(ParseFunctions(Body));
      end
      else
      begin
        Result.Body := Body;
      end;
    end;
  end;


begin
  Result := ParseFunctions(SBody);
end;

// -- preprocessor xml --


procedure TForm6.Button1Click(Sender: TObject);

  procedure RecurNode(XNode:TPreprocessorNode; TParent:TTreeNode);
  var
    I: Integer;
    N: TTreeNode;
  begin
    if XNode.Body<>'' then
      N:= TreeView1.Items.AddChild(TParent, PreprocessorNodeTypeStr[XNode.NType] + ' --  ' + StringReplace(XNode.Body,#13#10,'\r\n',[rfReplaceAll]))
    else
      N:= TreeView1.Items.AddChild(TParent, PreprocessorNodeTypeStr[XNode.NType] + ' --  ' + XNode.Param);

    for i := 0 to XNode.Childs.Count-1 do
      RecurNode(XNode.Childs[i], N);
  end;

var
  PT:TPreprocessorNode;
begin
  PT:=ParsePrePorcessor(Memo1.Lines.Text);
  try
    RecurNode(PT, nil);
    TreeView1.Items[0].Expand(true);
  finally
    PT.Free;
  end;
end;

procedure TForm6.Button2Click(Sender: TObject);
var
  L:TLexer;
  P:TParser;
begin
  TreeView1.Items.Clear;

  L:=TLexer.Create(MSouce.Lines.Text);
  try
    P := TParser.Create(L);
    try
      Describe(P.ParseProgram, nil);
    finally
      P.Free;
    end;
  finally
    L.Free;
  end;
end;

procedure TForm6.Button3Click(Sender: TObject);
var
  L:TLexer;
  E:TEnvironment;
  P:TParser;
begin
  L:=TLexer.Create('let a = (10 * 5) + 10;');
  try
    P := TParser.Create(L);
    try
      E:=TEnvironment.Create;
      try
        Eval(P.ParseProgram, E);
      finally
        E.Free;
      end;
    finally
      P.Free;
    end;
  finally
    L.Free;
  end;
end;

procedure TForm6.Describe(node: TASTNode; SParent: TTreeNode);
var
  N:TTreeNode;
  i:Integer;
begin
  if (node<>nil) then
  begin
    if node is TASTProgram then
    begin
      for i := 0 to TASTProgram(node).FStatements.Count-1 do
        Describe(TASTProgram(node).FStatements[i], nil);
    end
    else
    if node is TASTExpressionStatement then
      Describe(TASTExpressionStatement(node).Expression, TreeView1.Items.AddChild(SParent, node.toString))
    else
    if node is TASTLetStatement then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      N:= TreeView1.Items.AddChild(N, TASTLetStatement(node).Name.toString);
      Describe(TASTLetStatement(node).Expression, N);
    end
    else
    if node is TASTReturnStatement then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTReturnStatement(node).ReturnValue, N);
    end
    else
    if node is TASTBlockStatement then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      for i := 0 to TASTBlockStatement(node).Statements.Count-1 do
        Describe(TASTBlockStatement(node).Statements[i], N);
    end
    else
    if node is TASTPrefixExpression then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTPrefixExpression(node).Right, N);
    end
    else
    if node is TASTInfixExpression then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTInfixExpression(node).Left, N);
      Describe(TASTInfixExpression(node).Right, N);
    end
    else
    if node is TASTIfExpression then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTIfExpression(node).Condition, N);
      Describe(TASTIfExpression(node).Consequence, N);
      Describe(TASTIfExpression(node).Alternative, N);
    end
    else
    if node is TASTCallExpression then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTCallExpression(node).Funct, N);
      N:= TreeView1.Items.AddChild(N, 'args');
      for i := 0 to TASTCallExpression(node).Args.Count-1 do
        Describe(TASTCallExpression(node).Args[i], N);
    end
    else
    if node is TASTFunctionLiteral then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTFunctionLiteral(node).Body, N);
    end
    else
    if (node is TASTNumberLiteral)
    or (node is TASTBoolean)
    or (node is TASTIdentifier)
    then
      TreeView1.Items.AddChild(SParent, node.toString);
  end;
end;

procedure TForm6.FormCreate(Sender: TObject);

  procedure RecurNode(XNode:IXMLNode; TParent:TTreeNode);
  var
    I: Integer;
    N: TTreeNode;
  begin
    if XNode.NodeType=ntText then
      N:= TreeView1.Items.AddChild(TParent, XNode.Text)
    else
      N:= TreeView1.Items.AddChild(TParent, XNode.NodeName);

    if XNode.HasChildNodes then
      for i := 0 to XNode.ChildNodes.Count-1 do
        RecurNode(XNode.ChildNodes[i], N);
  end;

begin
//  RecurNode(XMLProps.ChildNodes[0], nil);
end;

{ TPreprocessorNode }

constructor TPreprocessorNode.Create(ANodeType:TPreprocessorNodeType; AParam:string; ABoby: string);
begin
  NType:= ANodeType;
  Param:= AParam;
  Body := ABoby;

  Childs := TObjectList<TPreprocessorNode>.create;
end;

destructor TPreprocessorNode.Destroy;
begin
  FreeAndNil(Childs);
end;

end.
