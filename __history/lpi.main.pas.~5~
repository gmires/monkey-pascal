unit lpi.main;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, xmldom, XMLIntf, msxmldom, XMLDoc, ComCtrls, StdCtrls

  ,Generics.Collections
  ,ExtCtrls
  ,lp.lexer, lp.token, lp.parser, lp.evaluator
  ;


type
  TForm6 = class(TForm)
    Panel1: TPanel;
    Button2: TButton;
    Panel2: TPanel;
    MSouce: TMemo;
    Button3: TButton;
    List: TListBox;
    Label1: TLabel;
    Label2: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
  private
    { Private declarations }
    procedure Describe(node: TASTNode; SParent:TTreeNode);
  public
    { Public declarations }
  end;

  TPreprocessorNodeType = (pntText, pntIf, pntEndIF, pntQry);

  TPreprocessorNode = class
    NType:TPreprocessorNodeType;
    Param:string;
    Body:string;
    Childs: TObjectList<TPreprocessorNode>;
  public
    constructor Create(ANodeType:TPreprocessorNodeType; AParam:string; ABoby: string);
    destructor Destroy; override;
  end;

const
  PreprocessorNodeTypeStr: Array[TPreprocessorNodeType] of string = ('NTEXT','NIF','NIFEND','NQR');

var
  Form6: TForm6;


implementation

{$R *.dfm}

procedure TForm6.Button2Click(Sender: TObject);
var
  L:TLexer;
  P:TParser;
begin

  L:=TLexer.Create(MSouce.Lines.Text);
  try
    P := TParser.Create(L);
    try
      Describe(P.ParseProgram, nil);
    finally
      P.Free;
    end;
  finally
    L.Free;
  end;
end;

procedure TForm6.Button3Click(Sender: TObject);
var
  L:TLexer;
  E:TEnvironment;
  P:TParser;
  O:TEvalObject;
begin
  L:=TLexer.Create(MSouce.Lines.Text);
  try
    P := TParser.Create(L);
    try
      E:=TEnvironment.Create;
      try
        O := Eval(P.ParseProgram, E);
        if O<>nil then
        try
          List.Items.Add(O.Inspect)
        finally
          O.Free;
        end;
      finally
        E.Free;
      end;
    finally
      P.Free;
    end;
  finally
    L.Free;
  end;
end;

procedure TForm6.Describe(node: TASTNode; SParent: TTreeNode);
var
  N:TTreeNode;
  i:Integer;
begin
  if (node<>nil) then
  begin
    if node is TASTProgram then
    begin
      for i := 0 to TASTProgram(node).FStatements.Count-1 do
        Describe(TASTProgram(node).FStatements[i], nil);
    end
    else
    if node is TASTExpressionStatement then
      Describe(TASTExpressionStatement(node).Expression, TreeView1.Items.AddChild(SParent, node.toString))
    else
    if node is TASTLetStatement then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      N:= TreeView1.Items.AddChild(N, TASTLetStatement(node).Name.toString);
      Describe(TASTLetStatement(node).Expression, N);
    end
    else
    if node is TASTReturnStatement then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTReturnStatement(node).ReturnValue, N);
    end
    else
    if node is TASTBlockStatement then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      for i := 0 to TASTBlockStatement(node).Statements.Count-1 do
        Describe(TASTBlockStatement(node).Statements[i], N);
    end
    else
    if node is TASTPrefixExpression then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTPrefixExpression(node).Right, N);
    end
    else
    if node is TASTInfixExpression then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTInfixExpression(node).Left, N);
      Describe(TASTInfixExpression(node).Right, N);
    end
    else
    if node is TASTIfExpression then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTIfExpression(node).Condition, N);
      Describe(TASTIfExpression(node).Consequence, N);
      Describe(TASTIfExpression(node).Alternative, N);
    end
    else
    if node is TASTCallExpression then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTCallExpression(node).Funct, N);
      N:= TreeView1.Items.AddChild(N, 'args');
      for i := 0 to TASTCallExpression(node).Args.Count-1 do
        Describe(TASTCallExpression(node).Args[i], N);
    end
    else
    if node is TASTFunctionLiteral then
    begin
      N:= TreeView1.Items.AddChild(SParent, node.toString);
      Describe(TASTFunctionLiteral(node).Body, N);
    end
    else
    if (node is TASTNumberLiteral)
    or (node is TASTStringLiteral)
    or (node is TASTBoolean)
    or (node is TASTIdentifier)
    then
      TreeView1.Items.AddChild(SParent, node.toString);
  end;
end;

procedure TForm6.FormCreate(Sender: TObject);

  procedure RecurNode(XNode:IXMLNode; TParent:TTreeNode);
  var
    I: Integer;
    N: TTreeNode;
  begin
    if XNode.NodeType=ntText then
      N:= TreeView1.Items.AddChild(TParent, XNode.Text)
    else
      N:= TreeView1.Items.AddChild(TParent, XNode.NodeName);

    if XNode.HasChildNodes then
      for i := 0 to XNode.ChildNodes.Count-1 do
        RecurNode(XNode.ChildNodes[i], N);
  end;

begin
//  RecurNode(XMLProps.ChildNodes[0], nil);
end;

{ TPreprocessorNode }

constructor TPreprocessorNode.Create(ANodeType:TPreprocessorNodeType; AParam:string; ABoby: string);
begin
  NType:= ANodeType;
  Param:= AParam;
  Body := ABoby;

  Childs := TObjectList<TPreprocessorNode>.create;
end;

destructor TPreprocessorNode.Destroy;
begin
  FreeAndNil(Childs);
end;

end.
