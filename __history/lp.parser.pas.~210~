unit lp.parser;

interface

uses SysUtils, Classes, Generics.Collections
  , lp.token, lp.lexer;

type
  TEXPrecedence = (
	  LOWEST
	  , EQUALS
	  , LESSGREATER
	  , SUM
	  , PRODUCT
	  , PREFIX
	  , CALL
  );

  TASTNode = class
  public
    function toString:string; virtual;
  end;

  TASTStatement = class(TASTNode)
  public
    Token: TToken;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TASTExpression = class(TASTNode)
  public
    Token: TToken;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TASTProgram = class(TASTNode)
    FStatements:TList<TASTStatement>;
  public
    constructor Create;
    destructor Destroy; override;
    property Statements:TList<TASTStatement> read FStatements;
  end;

  TASTNumberLiteral = class(TASTExpression)
  public
    Value: Double;
    function toString:string; override;
  public
  end;

  TASTIdentifier = class(TASTExpression)
  public
    Value: string;
    function toString:string; override;
  end;

  TASTBoolean = class(TASTExpression)
  public
    Value: Boolean;
    function toString:string; override;
  end;

  TASTPrefixExpression = class(TASTExpression)
  public
    Op:string;
    Right: TASTExpression;
    function toString:string; override;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TASTInfixExpression = class(TASTExpression)
  public
    Left: TASTExpression;
    Op:string;
    Right: TASTExpression;
    function toString:string; override;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TASTExpressionStatement = class(TASTStatement)
  public
    Expression: TASTExpression;
    function toString:string; override;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TASTLetStatement = class(TASTStatement)
  public
    Name: TASTIdentifier;
    Expression: TASTExpression;
    function toString:string; override;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TASTReturnStatement = class(TASTStatement)
  public
    ReturnValue: TASTExpression;
    function toString:string; override;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TASTBlockStatement = class(TASTStatement)
    FStatements:TList<TASTStatement>;
    function toString:string; override;
  public
    constructor Create;
    destructor Destroy; override;
    property Statements:TList<TASTStatement> read FStatements;
  end;

  TASTIfExpression = class(TASTExpression)
  public
    Condition: TASTExpression;
    Consequence: TASTBlockStatement;
    Alternative: TASTBlockStatement;
    function toString:string; override;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TASTFunctionLiteral = class(TASTExpression)
    Parameters:TList<TASTIdentifier>;
    Body: TASTBlockStatement;
    function toString:string; override;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TASTCallExpression = class(TASTExpression)
    Funct:TASTExpression;
    Args: TList<TASTExpression>;
    function toString:string; override;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TParsePrefixExpression = function:TASTExpression of object;
  TParseInfixExpression = function(AExpression:TASTExpression):TASTExpression of object;

  TParser = class
    Lexer: TLexer;
    CurrToken:TToken;
    PeekToken:TToken;
    Precedences: TDictionary<TTokenType,TEXPrecedence>;
    PrefixFuncts: TDictionary<TTokenType,TParsePrefixExpression>;
    InfixFuncts: TDictionary<TTokenType,TParseInfixExpression>;
    procedure nextToken;
    function  peekTokenIs(TType:TTokenType): Boolean;
    function  currPrecedence: TEXPrecedence;
    function  peekPrecedence: TEXPrecedence;
    function  expectPeek(TType:TTokenType):Boolean;
    // ---------
    function ParseStatement: TASTStatement;
    function ParseExpressionStatement: TASTExpressionStatement;
    function ParseLetStatement: TASTLetStatement;
    function ParseReturnStatement: TASTReturnStatement;
    function ParseBlockStatement: TASTBlockStatement;
    // ---------
    function ParseExpression(APrecedence:TEXPrecedence): TASTExpression;
    function ParseNumberLiteral:TASTExpression;
    function ParsePrefixExpression:TASTExpression;
    function ParseInfixExpression(left:TASTExpression):TASTExpression;
    function ParseGroupExpression:TASTExpression;
    function ParseIdentifier:TASTExpression;
    function ParseBoolean:TASTExpression;
    function ParseIfExpression:TASTExpression;
    function ParseFunctionLiteral:TASTExpression;
    function ParseFunctionParameters:TList<TASTIdentifier>;
    function ParseCallExpression(funct:TASTExpression):TASTExpression;
    function ParseCallArguments:TList<TASTExpression>;
    // -----------
  public
    constructor Create(ALexer:TLexer);
    destructor Destroy; override;

    function ParseProgram: TASTProgram;
  end;

implementation

procedure FreeAndNilAssigned(var Obj);
begin
  if Assigned(TObject(Obj)) then
    FreeAndNil(Obj);
end;

{ TParser }

constructor TParser.Create(ALexer: TLexer);
begin
  Precedences:= TDictionary<TTokenType,TEXPrecedence>.Create;
  Precedences.Add(ttEQ, TEXPrecedence.EQUALS);
  Precedences.Add(ttNOT_EQ, TEXPrecedence.EQUALS);
  Precedences.Add(ttLT, LESSGREATER);
  Precedences.Add(ttGT, LESSGREATER);
  Precedences.Add(ttPLUS, SUM);
  Precedences.Add(ttMINUS, SUM);
  Precedences.Add(ttSLASH, PRODUCT);
  Precedences.Add(ttASTERISK, PRODUCT);
  Precedences.Add(ttLPAREN, CALL);

  PrefixFuncts:= TDictionary<TTokenType,TParsePrefixExpression>.Create;
  PrefixFuncts.Add(ttIDENT, ParseIdentifier);
  PrefixFuncts.Add(ttNUMBER, ParseNumberLiteral);
  PrefixFuncts.Add(ttBANG, ParsePrefixExpression);
  PrefixFuncts.Add(ttMINUS, ParsePrefixExpression);
  PrefixFuncts.Add(ttTRUE, ParseBoolean);
  PrefixFuncts.Add(ttFALSE, ParseBoolean);
  PrefixFuncts.Add(ttLPAREN, ParseGroupExpression);
	PrefixFuncts.Add(ttIF, ParseIfExpression);
	PrefixFuncts.Add(ttFUNCTION, ParseFunctionLiteral);

  InfixFuncts := TDictionary<TTokenType,TParseInfixExpression>.Create;
  InfixFuncts.Add(ttPLUS, ParseInfixExpression);
  InfixFuncts.Add(ttMINUS, ParseInfixExpression);
  InfixFuncts.Add(ttSLASH, ParseInfixExpression);
  InfixFuncts.Add(ttASTERISK, ParseInfixExpression);
	InfixFuncts.Add(ttEQ, ParseInfixExpression);
	InfixFuncts.Add(ttNOT_EQ, ParseInfixExpression);
	InfixFuncts.Add(ttLT, ParseInfixExpression);
	InfixFuncts.Add(ttGT, ParseInfixExpression);
//	InfixFuncts.Add(ttLPAREN, ParseCallExpression);

  Lexer := ALexer;
  CurrToken:=nil;
  PeekToken:=nil;

  nextToken;
  nextToken;
end;

function TParser.currPrecedence: TEXPrecedence;
begin
  if Precedences.ContainsKey(CurrToken.TokenType) then
    Result := Precedences[CurrToken.TokenType]
  else
    Result := LOWEST;
end;

destructor TParser.Destroy;
begin
  PrefixFuncts.Free;
  InfixFuncts.Free;
  Precedences.Free;
end;

function TParser.expectPeek(TType: TTokenType): Boolean;
begin
  Result := peekTokenIs(TType);
  if Result then
    nextToken;
end;

procedure TParser.nextToken;
begin
  if (CurrToken<>nil) then FreeAndNil(CurrToken);
  CurrToken := PeekToken;
  PeekToken := Lexer.NextToken;
end;

function TParser.ParseBlockStatement: TASTBlockStatement;
var
  stmt : TASTStatement;
begin
  Result := TASTBlockStatement.Create;
  Result.Token := CurrToken;

  nextToken;
  while ((CurrToken.TokenType<>ttRBRACE) and NOT (CurrToken.TokenType=ttEOF)) do
  begin
    stmt := ParseStatement;
    if (stmt<>nil) then
      Result.Statements.Add(stmt);

    nextToken;
  end;
end;

function TParser.ParseBoolean: TASTExpression;
begin
  Result := TASTBoolean.Create;
  Result.Token := CurrToken;
  TASTBoolean(Result).Value:= (CurrToken.TokenType = ttTRUE);
end;

function TParser.ParseCallArguments: TList<TASTExpression>;
begin
  Result := TList<TASTExpression>.Create;

  if NOT peekTokenIs(ttRPAREN) then
  begin
    nextToken;
    Result.Add(ParseExpression(LOWEST));

    while peekTokenIs(ttCOMMA) do
    begin
      nextToken;
      nextToken;

      Result.Add(ParseExpression(LOWEST));
    end;



  end
  else nextToken;
end;

function TParser.ParseCallExpression(funct: TASTExpression): TASTExpression;
begin
  Result := TASTCallExpression.Create;
  Result.Token := CurrToken;
  TASTCallExpression(Result).Funct := funct;
  TASTCallExpression(Result).Args := ParseCallArguments;
end;

function TParser.ParseExpression(APrecedence:TEXPrecedence): TASTExpression;
var
  prefixFn: TParsePrefixExpression;
  infixFn: TParseInfixExpression;
begin
  Result:= nil;
  if PrefixFuncts.TryGetValue(CurrToken.TokenType, prefixFn) then
  begin
    Result := prefixFn();
    while NOT peekTokenIs(ttSEMICOLON) and (APrecedence<peekPrecedence) do
    begin
      if InfixFuncts.TryGetValue(PeekToken.TokenType, infixFn) then
      begin
        nextToken;
        Result := infixFn(Result);
      end
      else Break;
    end;

  end;
end;

function TParser.ParseExpressionStatement: TASTExpressionStatement;
begin
  Result := TASTExpressionStatement.Create;
  Result.Token := CurrToken;
  Result.Expression := ParseExpression(LOWEST);

  if peekTokenIs(ttSEMICOLON) then
    nextToken;
end;

function TParser.ParseFunctionLiteral: TASTExpression;
begin
  Result := TASTFunctionLiteral.Create;
  Result.Token := CurrToken;

  if expectPeek(ttLPAREN) then
  begin
    TASTFunctionLiteral(Result).Parameters := ParseFunctionParameters;
    if expectPeek(ttLBRACE) then
      TASTFunctionLiteral(Result).Body := ParseBlockStatement;
  end;

end;

function TParser.ParseFunctionParameters: TList<TASTIdentifier>;
var
  Ident:TASTIdentifier;
begin
  Result := TList<TASTIdentifier>.Create;
  if NOT peekTokenIs(ttRPAREN) then
  begin
    nextToken;

    Ident := TASTIdentifier.Create;
    Ident.Token := CurrToken;
    Ident.Value := CurrToken.Literal;
    Result.Add(Ident);

    while peekTokenIs(ttCOMMA) do
    begin
      nextToken;
      nextToken;

      Ident := TASTIdentifier.Create;
      Ident.Token := CurrToken;
      Ident.Value := CurrToken.Literal;
      Result.Add(Ident);
    end;

    expectPeek(ttRPAREN);
  end
  else nextToken;
end;

function TParser.ParseGroupExpression: TASTExpression;
var
  Expr:TASTExpression;
begin
  Result := nil;
  nextToken;

  Expr := ParseExpression(LOWEST);
  if expectPeek(ttRPAREN) then
    Result := Expr;
end;

function TParser.ParseIdentifier: TASTExpression;
begin
  Result := TASTIdentifier.Create;
  Result.Token := CurrToken;
  TASTIdentifier(Result).Value:= CurrToken.Literal;
end;

function TParser.ParseIfExpression: TASTExpression;
begin
  Result := TASTIfExpression.Create;
  Result.Token := CurrToken;

  if expectPeek(ttLPAREN) then
  begin
    nextToken;
    TASTIfExpression(Result).Condition := ParseExpression(LOWEST);

    if expectPeek(ttRPAREN) then
      if expectPeek(ttLBRACE) then
      begin
        TASTIfExpression(Result).Consequence := ParseBlockStatement;
        if peekTokenIs(ttELSE) then
        begin
          nextToken;
          if expectPeek(ttLBRACE) then
            TASTIfExpression(Result).Alternative := ParseBlockStatement;
        end;
      end;
  end;

end;

function TParser.ParseInfixExpression(left: TASTExpression): TASTExpression;
var
  precedence: TEXPrecedence;
begin
  Result := TASTInfixExpression.Create;
  TASTInfixExpression(Result).Token := CurrToken;
  TASTInfixExpression(Result).Op  := CurrToken.Literal;
  TASTInfixExpression(Result).Left:= left;

  precedence := currPrecedence;
	nextToken;

	TASTInfixExpression(Result).Right := parseExpression(precedence);
end;

function TParser.ParseLetStatement: TASTLetStatement;
begin
  Result := TASTLetStatement.Create;
  Result.Token := CurrToken;
  if expectPeek(ttIDENT) then
  begin
    Result.Name := TASTIdentifier.Create;
    Result.Name.Token := CurrToken;
    Result.Name.Value := CurrToken.Literal;
    if expectPeek(ttASSIGN) then
    begin
      nextToken;
      Result.Expression := ParseExpression(LOWEST);

      if peekTokenIs(ttSEMICOLON) then
        nextToken;
    end;
  end;
end;

function TParser.ParseNumberLiteral: TASTExpression;
begin
  Result:= TASTNumberLiteral.Create;
  TASTNumberLiteral(Result).Token := CurrToken;
  TASTNumberLiteral(Result).Value := StrToFloatDef(StringReplace(CurrToken.Literal,'.',FormatSettings.DecimalSeparator,[]),0);
end;

function TParser.ParsePrefixExpression: TASTExpression;
begin
  Result := TASTPrefixExpression.Create;
  TASTPrefixExpression(Result).Token := CurrToken;
  TASTPrefixExpression(Result).Op := CurrToken.Literal;

  nextToken;

  TASTPrefixExpression(Result).Right := ParseExpression(PREFIX);
end;

function TParser.ParseProgram: TASTProgram;
var
  stmt: TASTStatement;
begin
  Result := TASTProgram.Create;

  While (CurrToken.TokenType <> ttEOF ) do
  begin
    stmt := ParseStatement;
    if (stmt <> nil) then
      Result.Statements.Add(stmt);

    nextToken;
  end;
end;

function TParser.ParseReturnStatement: TASTReturnStatement;
begin
  Result := TASTReturnStatement.Create;
  Result.Token := CurrToken;

  nextToken;

  Result.ReturnValue := ParseExpression(LOWEST);

  if peekTokenIs(ttSEMICOLON) then
    nextToken;
end;

function TParser.ParseStatement: TASTStatement;
begin
  case CurrToken.TokenType of
    ttLET: Result := ParseLetStatement;
    ttRETURN: Result := ParseReturnStatement;
  else
    Result := ParseExpressionStatement;
  end;
end;

function TParser.peekPrecedence: TEXPrecedence;
begin
  if Precedences.ContainsKey(PeekToken.TokenType) then
    Result := Precedences[PeekToken.TokenType]
  else
    Result := LOWEST;
end;

function TParser.peekTokenIs(TType: TTokenType): Boolean;
begin
  Result := (PeekToken.TokenType = TType);
end;

{ TASTProgram }

constructor TASTProgram.Create;
begin
  FStatements := TList<TASTStatement>.Create;
end;

destructor TASTProgram.Destroy;
var
  i: Integer;
begin
  for i := FStatements.Count-1 downto 0 do
    FStatements[i].Free;
  FStatements.Free;
end;

{ TASTStatement }

constructor TASTStatement.Create;
begin
  Token := nil;
end;

destructor TASTStatement.Destroy;
begin
  FreeAndNilAssigned(Token);
  inherited;
end;

{ TASTExpression }

constructor TASTExpression.Create;
begin
  inherited;
  Token := nil;
end;

destructor TASTExpression.Destroy;
begin
  FreeAndNilAssigned(Token);
  inherited;
end;

{ TASTExpressionStatement }

constructor TASTExpressionStatement.Create;
begin
  Expression := nil;
end;

destructor TASTExpressionStatement.Destroy;
begin
  FreeAndNilAssigned(Expression);
  inherited;
end;

function TASTExpressionStatement.toString: string;
begin
  Result := 'Expression Stmt';
end;

{ TASTNumberLiteral }

function TASTNumberLiteral.toString: string;
begin
  Result := 'Number = ' + FloatToStr(Value);
end;

{ TASTPrefixExpression }

constructor TASTPrefixExpression.Create;
begin
  inherited;
  Op := '';
  Right := nil;
end;

destructor TASTPrefixExpression.Destroy;
begin
  FreeAndNilAssigned(Right);
  inherited;
end;

function TASTPrefixExpression.toString: string;
begin
  Result := 'Prefix Operator = ' + Op;
end;

{ TASTInfixExpression }

constructor TASTInfixExpression.Create;
begin
  Op:='';;
  Left:=nil;
  Right:=nil;
end;

destructor TASTInfixExpression.Destroy;
begin
  FreeAndNilAssigned(Right);
  FreeAndNilAssigned(Left);
  inherited;
end;

function TASTInfixExpression.toString: string;
begin
  Result := 'Infix Operator = ' + op;
end;

{ TASTIdentifier }

function TASTIdentifier.toString: string;
begin
  Result := 'Identifier = ' + Value;
end;

{ TASTLetStatement }

constructor TASTLetStatement.Create;
begin
  Name := nil;
  Expression := nil;
end;

destructor TASTLetStatement.Destroy;
begin
  FreeAndNilAssigned(Expression);
  FreeAndNilAssigned(Name);
  inherited;
end;

function TASTLetStatement.toString: string;
begin
  Result := 'Let Stmt';
end;

{ TASTReturnStatement }

constructor TASTReturnStatement.Create;
begin
  ReturnValue := nil;
end;

destructor TASTReturnStatement.Destroy;
begin
  FreeAndNilAssigned(ReturnValue);
  inherited;
end;

function TASTReturnStatement.toString: string;
begin
  Result := 'Return Stmt';
end;

{ TASTBoolean }

function TASTBoolean.toString: string;
begin
  if Value then
    Result := 'True'
  else
    Result := 'False';
end;

{ TASTBlockStatement }

constructor TASTBlockStatement.Create;
begin
  FStatements := TList<TASTStatement>.Create;
end;

destructor TASTBlockStatement.Destroy;
var
  i: Integer;
begin
  for i := FStatements.Count-1 downto 0 do
    FStatements[i].Free;
  FStatements.Free;
  inherited;
end;

function TASTBlockStatement.toString: string;
begin
  Result := 'Block stmt';
end;

{ TASTIfExpression }

constructor TASTIfExpression.Create;
begin
  Condition:=nil;
  Consequence:=nil;
  Alternative:=nil;
end;

destructor TASTIfExpression.Destroy;
begin
  FreeAndNilAssigned(Condition);
  FreeAndNilAssigned(Consequence);
  FreeAndNilAssigned(Alternative);
  inherited;
end;

function TASTIfExpression.toString: string;
begin
  Result := 'if ';
end;

{ TASTFunctionLiteral }

constructor TASTFunctionLiteral.Create;
begin
  Parameters := nil;
  Body := nil;
end;

destructor TASTFunctionLiteral.Destroy;
var
  i: Integer;
begin
  FreeAndNilAssigned(Body);
  if Parameters<>nil then
  begin
    for i := Parameters.Count-1 downto 0 do
      Parameters[i].Free;
    Parameters.Free;
  end;
  inherited;
end;

function TASTFunctionLiteral.toString: string;
begin
  Result := 'function';
end;

{ TASTNode }

function TASTNode.toString: string;
begin
  Result := ''; { -- virtual -- }
end;

{ TASTCallExpression }

constructor TASTCallExpression.Create;
begin
  Funct := nil;
  Args := nil;
end;

destructor TASTCallExpression.Destroy;
var
  i: Integer;
begin
  FreeAndNilAssigned(Funct);
  if Args<>nil then
  begin
    for i := Args.Count-1 downto 0 do
      Args[i].Free;
    Args.Free;
  end;
  inherited;
end;

function TASTCallExpression.toString: string;
begin

end;

end.
