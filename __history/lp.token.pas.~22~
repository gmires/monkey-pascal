unit lp.token;

interface

uses Classes, Generics.Collections;

type
  TTokenType = (
    // base
      ttILLEGAL
    , ttEOF
    , ttNUMBER
    // Operators
    , ttPLUS      // = "+"
    , ttMINUS     // = "-"
    , ttASTERISK  // = "*"
    , ttSLASH     // = "/"
    // others
    , ttLPAREN    // = "("
    , ttRPAREN    // = ")"
    , ttSEMICOLON // = ";"

    , ttLET // = "LET"
    , ttASSIGN // = "="
    , ttIDENT // = "IDENT"
  );

  TToken = class
  public
    constructor create(ATokenType:TTokenType; ALiteral:string);
    function toString:string;
  public
    TokenType:TTokenType;
    Literal:string;
  end;

function LookupIdent(value:string): TTokenType;

implementation

var
  keywords:TDictionary<string,TTokenType>;

function LookupIdent(value:string): TTokenType;
begin
  if NOT keywords.TryGetValue(value, Result) then
    Result := ttIDENT;
end;

{ TToken }

constructor TToken.create(ATokenType: TTokenType; ALiteral: string);
begin
  TokenType := ATokenType;
  Literal := ALiteral;
end;

function TToken.toString: string;
const
  TTypeStr: array[TTokenType] of string = (
    'ILLEGAL'
    , 'EOF'
    , 'NUMBER'
    , 'PLUS'
    , 'MINUS'
    , 'ASTERISK'
    , 'SLASH'
    , 'LPAREN'
    , 'RPAREN'
    , 'SEMICOLON'
    , 'LET'
    , 'ASSIGN'
    , 'IDENT'
  );
begin
  Result := 'TK Type = ' + TTypeStr[TokenType] + ', literal value = ' + Literal;
end;

procedure init;
begin
  keywords := TDictionary<string,TTokenType>.Create;
  keywords.Add('let', ttLET);
end;

procedure deinit;
begin
  keywords.Free;
end;

initialization
  init;

finalization
  deinit;

end.
