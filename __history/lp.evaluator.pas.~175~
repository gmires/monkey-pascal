unit lp.evaluator;

interface

uses classes, SysUtils, Generics.Collections, Variants

  , lp.environment
  , lp.parser;



var
  builtins: TDictionary<string,TBuiltinObject>;
//  _NULL_ :TNullObject;
//  _TRUE_ :TBooleanObject;
//  _FALSE_:TBooleanObject;

  // ---- Evaluator Function --------------------

function Eval(node: TASTNode; env: TEnvironment): TEvalObject;

implementation

function nativeBoolToBooleanObject(input:Boolean): TBooleanObject;
begin
  Result := TBooleanObject.Create(input);
end;

function newError(const AFormat: string; const Args: Array of const):TErrorObject;
begin
  Result := TErrorObject.Create(Format(AFormat, Args));
end;

function isError(obj: TEvalObject):Boolean;
begin
  Result := False;
	if (obj <> nil) then
		Result := (obj.ObjetcType() = ERROR_OBJ);
end;

function isTruthy(obj:TEvalObject): Boolean;
begin
  Result := True;
  if obj is TNullObject then Result := false
  else
  if obj is TBooleanObject then Result := TBooleanObject(obj).Value;
end;

function evalProgram(node: TASTNode; env: TEnvironment): TEvalObject;
var
  i: Integer;
  R: TEvalObject;
begin
  R := nil;
  for i := 0 to TASTProgram(node).FStatements.Count-1 do
  begin
    R := Eval(TASTProgram(node).FStatements[i], env);
    if R is TReturnValueObject then
    begin
      Result := TReturnValueObject(R).Value;
      Exit;
    end
    else
    if R is TErrorObject then Break;
  end;
  Result := R;
end;

function evalBlockStatements(node :TASTBlockStatement; env: TEnvironment): TEvalObject;
var
  i: Integer;
begin
  Result := nil;
  for i := 0 to TASTBlockStatement(node).FStatements.Count-1 do
  begin
    Result := Eval(TASTBlockStatement(node).FStatements[i], env);
    if (Result<>nil) then
      if (Result.ObjetcType = RETURN_VALUE_OBJ) or (Result.ObjetcType = ERROR_OBJ) then
        Break;
  end;

end;

function evalBangOperatorExpression(right: TEvalObject):TEvalObject;
begin
  if (right is TNullObject) then
    Result := TBooleanObject.Create(True)
  else
  if (right is TBooleanObject) then
    Result := TBooleanObject.Create(NOT TBooleanObject(right).Value)
  else
    Result :=  TBooleanObject.Create(False);
end;

function evalMinusPrefixOperatorExpression(right: TEvalObject): TEvalObject;
begin

  if (right.ObjetcType <> NUMBER_OBJ) then
    Result := newError('unknown operator: -%s', [right.ObjetcType])
  else
    Result := TNumberObject.Create(-TNumberObject(right).Value);
end;

function evalPrefixExpression(Op:string; right:TEvalObject):TEvalObject;
begin
  if Op='!' then Result := evalBangOperatorExpression(right)
  else
  if Op='-' then Result := evalMinusPrefixOperatorExpression(right)
  else
    Result := newError('unknown operator: %s%s', [Op, right.ObjetcType])
end;

function evalIntegerInfixExpression(Op: string; left, right: TEvalObject): TEvalObject;
var
  LVal,
  RVal:Double;
begin
  LVal:= TNumberObject(left).Value;
  RVal:= TNumberObject(right).Value;
  if Op='+' then Result:= TNumberObject.Create(LVal + RVal)
  else
  if Op='-' then Result:= TNumberObject.Create(LVal - RVal)
  else
  if Op='*' then Result:= TNumberObject.Create(LVal * RVal)
  else
  if Op='/' then Result:= TNumberObject.Create(LVal / RVal)
  else
  if Op='<' then Result:= nativeBoolToBooleanObject(LVal < RVal)
  else
  if Op='>' then Result:= nativeBoolToBooleanObject(LVal > RVal)
  else
  if Op='==' then Result:= nativeBoolToBooleanObject(LVal = RVal)
  else
  if Op='!=' then Result:= nativeBoolToBooleanObject(LVal <> RVal)
  else
    Result := newError('unknown operator: %s %s %s', [left.ObjetcType, Op, right.ObjetcType])
end;

function evalStringInfixExpression(Op: string; left, right: TEvalObject): TEvalObject;
var
  LVal,
  RVal:string;
begin
  LVal:= TStringObject(left).Value;
  RVal:= TStringObject(right).Value;
  if Op='+' then Result:= TStringObject.Create(LVal + RVal)
  else
  if Op='<' then Result:= nativeBoolToBooleanObject(LVal < RVal)
  else
  if Op='>' then Result:= nativeBoolToBooleanObject(LVal > RVal)
  else
  if Op='==' then Result:= nativeBoolToBooleanObject(LVal = RVal)
  else
  if Op='!=' then Result:= nativeBoolToBooleanObject(LVal <> RVal)
  else
    Result := newError('unknown operator: %s %s %s', [left.ObjetcType, Op, right.ObjetcType])
end;

function evalInfixExpression(Op:string; left, right: TEvalObject):TEvalObject;
begin
  if ((left.ObjetcType=NUMBER_OBJ) and (right.ObjetcType=NUMBER_OBJ)) then
    Result := evalIntegerInfixExpression(Op, left, right)
  else
  if ((left.ObjetcType=STRING_OBJ) and (right.ObjetcType=STRING_OBJ)) then
    Result := evalStringInfixExpression(Op, left, right)
  else
  if (Op='==') then
    Result := nativeBoolToBooleanObject(left = right)
  else
  if (Op='!=') then
    Result := nativeBoolToBooleanObject(left <> right)
  else
  if (left.ObjetcType<>right.ObjetcType) then
		Result := newError('type mismatch: %s %s %s', [left.ObjetcType, Op, right.ObjetcType])
  else
		Result := newError('unknown operator: %s %s %s', [left.ObjetcType, Op, right.ObjetcType])
end;

function evalIfExpression(node:TASTIfExpression; env :TEnvironment):TEvalObject;
begin
  Result := Eval(TASTIfExpression(node).Condition, env);
  if NOT isError(Result) then
  begin
    if isTruthy(Result) then
      Result := Eval(TASTIfExpression(node).Consequence, env)
    else
    if (TASTIfExpression(node).Alternative<> nil) then
      Result := Eval(TASTIfExpression(node).Alternative, env)
    else
      Result := TNullObject.Create;
  end;
end;

function evalIdentifier(node: TASTIdentifier; env :TEnvironment):TEvalObject;
begin
  Result:=nil;

  if NOT env.GetValue(node.Value, Result) then
  begin
    if builtins.ContainsKey(node.Value) then
      Result := builtins[node.Value]
    else
      Result := newError('identifier not found: %s ',[node.Value]);
  end;
end;

function evalExpressions(exps:TList<TASTExpression>; env:TEnvironment):TList<TEvalObject>;
var
  i:Integer;
  val:TEvalObject;
begin
  Result := TList<TEvalObject>.Create;
  for i := 0 to exps.Count-1 do
  begin
    val := Eval(exps[i], env);
    if isError(val) then
    begin
      Result.Clear;
      Result.Add(val);
      Break;
    end;
    Result.Add(val);
  end;
end;

function extendFunctionEnv(fn: TFunctionObject; args: TList<TEvalObject>):TEnvironment;
var
  i: Integer;
begin
  Result := TEnvironment.Create(fn.Env);
  for i := 0 to fn.Parameters.Count-1 do
    Result.SetValue(fn.Parameters[i].Value,args[i]);
end;

function unwrapReturnValue(obj:TEvalObject):TEvalObject;
begin
  Result := nil;
  if (obj is TReturnValueObject) then
    if (TReturnValueObject(obj).Value<>nil) then
       Result := TReturnValueObject(obj).Value;

  if Result=nil then
    Result := obj;
end;


function applyFunction(fn: TEvalObject; args: TList<TEvalObject>):TEvalObject;
begin
  if (fn is TFunctionObject) then
    Result := unwrapReturnValue(Eval(TFunctionObject(fn).Body, extendFunctionEnv(fn as TFunctionObject, args)))
  else
  if (fn is TBuiltinObject) then
    Result := TBuiltinObject(fn).BuiltinFunction(args)
  else
    Result := newError('not a function: %s', [fn.ObjetcType])
end;


function Eval(node: TASTNode; env: TEnvironment): TEvalObject;
var
  val:TEvalObject;
  args:TList<TEvalObject>;
begin
  Result := nil;
  if node is TASTProgram then
    Result := evalProgram(node, env)
  else
  if node is TASTExpressionStatement then
    Result := Eval(TASTExpressionStatement(node).Expression, env)
  else
  if node is TASTNumberLiteral then
    Result := TNumberObject.Create(TASTNumberLiteral(node).Value)
  else
  if node is TASTBoolean then
    Result := nativeBoolToBooleanObject(TASTBoolean(node).Value)
  else
  if node is TASTStringLiteral then
    Result := TStringObject.Create(TASTStringLiteral(node).Value)
  else
  if node is TASTPrefixExpression then
  begin
    Result := Eval(TASTPrefixExpression(node).Right, env);
		if NOT isError(Result) then
  		Result := evalPrefixExpression(TASTPrefixExpression(node).Op, Result)
  end
  else
  if node is TASTInfixExpression then
  begin
    Result := Eval(TASTInfixExpression(node).Left, env);
    if NOT isError(Result)  then
    begin
      val := Eval(TASTInfixExpression(node).Right, env);
      if isError(Result)  then
        Result := val
      else
        Result := evalInfixExpression(TASTInfixExpression(node).Op, Result, val);
    end;
  end
  else
  if node is TASTBlockStatement then
    Result := evalBlockStatements(node as TASTBlockStatement, env)
  else
  if node is TASTIfExpression then
    Result := evalIfExpression(node as TASTIfExpression, env)
  else
  if node is TASTReturnStatement then
  begin
    Result := Eval(TASTReturnStatement(node).ReturnValue, env);
		if NOT isError(Result) then
      Result := TReturnValueObject.Create(Result);
  end
  else
  if node is TASTLetStatement then
  begin
    val := Eval(TASTLetStatement(node).Expression, env);
    if NOT isError(val) then
      env.SetValue(TASTLetStatement(node).Name.Value, val)
    else
      Result := val;
  end
  else
  if node is TASTIdentifier then
    Result := evalIdentifier(node as TASTIdentifier, env)
  else
  if node is TASTFunctionLiteral then
    Result := TFunctionObject.Create(TASTFunctionLiteral(node).Parameters,TASTFunctionLiteral(node).Body, env)
  else
  if node is TASTCallExpression then
  begin
    Result := Eval(TASTCallExpression(node).Funct, env);
    if NOT isError(Result) then
    begin
		  args := evalExpressions(TASTCallExpression(node).Args, env);
      if ((args.Count=1) and (isError(args[0]))) then
        Result := args[0]
      else
        Result := applyFunction(Result, args);
    end;
  end;
end;

{ TEvalObject }

function TEvalObject.Inspect: string;
begin
  Result := '';
end;

function TEvalObject.ObjetcType: TEvalObjectType;
begin
  Result := '';
end;

{ TNumberObject }

constructor TNumberObject.Create(AValue: Double);
begin
  Value := AValue;
end;

function TNumberObject.Inspect: string;
begin
  Result := FloatToStr(Value)
end;

function TNumberObject.ObjetcType: TEvalObjectType;
begin
  Result := NUMBER_OBJ;
end;

{ TBooleanObject }

constructor TBooleanObject.Create(AValue: Boolean);
begin
  Value := AValue;
end;

function TBooleanObject.Inspect: string;
begin
  if Value then Result := 'True' else Result := 'False';
end;

function TBooleanObject.ObjetcType: TEvalObjectType;
begin
  Result := BOOLEAN_OBJ;
end;

{ TReturnValueObject }

constructor TReturnValueObject.Create;
begin
  Value := nil;
end;

constructor TReturnValueObject.Create(AValue: TEvalObject);
begin
  Create;
  if AValue is TNumberObject  then Value := TNumberObject.Create(TNumberObject(AValue).Value)
  else
  if AValue is TBooleanObject then Value := TBooleanObject.Create(TBooleanObject(AValue).Value)
  else
  if AValue is TStringObject then Value := TStringObject.Create(TStringObject(AValue).Value)
  else
  if AValue is TNumberObject then Value := TNullObject.Create
  else
  if AValue is TErrorObject then Value := TErrorObject.Create(TErrorObject(AValue).ErrMessage)
  else
  if AValue is TFunctionObject then
    Value := TFunctionObject.Create(TFunctionObject(AValue).Parameters
      ,TFunctionObject(AValue).Body
      ,TFunctionObject(AValue).Env);
end;

destructor TReturnValueObject.Destroy;
begin
{  if (Value<>nil) then
    FreeAndNil(Value);}
  inherited;
end;

function TReturnValueObject.Inspect: string;
begin
  Result := Value.Inspect;
end;

function TReturnValueObject.ObjetcType: TEvalObjectType;
begin
  Result := RETURN_VALUE_OBJ;
end;

{ TErrorObject }

constructor TErrorObject.Create(AErrMessage: string);
begin
  ErrMessage := AErrMessage;
end;

function TErrorObject.Inspect: string;
begin
  Result := 'ERROR: ' + ErrMessage;
end;

function TErrorObject.ObjetcType: TEvalObjectType;
begin
  Result := ERROR_OBJ;
end;

{ TFunctionObject }

constructor TFunctionObject.Create(AParameters: TList<TASTIdentifier>;
  ABody: TASTBlockStatement; AEnv: TEnvironment);
begin
  Parameters := AParameters;
  Body := ABody;
  Env := AEnv;
end;

destructor TFunctionObject.Destroy;
begin

  inherited;
end;

function TFunctionObject.Inspect: string;
begin
  Result := '';
end;

function TFunctionObject.ObjetcType: TEvalObjectType;
begin
  Result := FUNCTION_OBJ;
end;

{ TEnvironment }

constructor TEnvironment.Create;
begin
  FStore := TDictionary<string,TEvalObject>.Create;
  FOuter := nil;
end;

constructor TEnvironment.Create(AOuter: TEnvironment);
begin
  Create;
  FOuter := AOuter;
end;

destructor TEnvironment.Destroy;
var
  key :string;
begin
  for key in FStore.Keys do
    FStore[key].Free;
  FStore.Free;
  if (FOuter<>nil) then FOuter.Free;
  inherited;
end;

function TEnvironment.GetValue(name: string; var value: TEvalObject): Boolean;
begin
  Result := FStore.TryGetValue(name, value);
  if NOT Result and Assigned(Outer) then
    Result := Outer.GetValue(name, value);
end;

function TEnvironment.SetValue(name: string; value: TEvalObject): TEvalObject;
begin
  Result := value;
  FStore.Add(name, Result);
end;

{ TNullObject }

function TNullObject.Inspect: string;
begin
  Result := 'Null';
end;

function TNullObject.ObjetcType: TEvalObjectType;
begin
  Result := NULL_OBJ;
end;

{ TStringObject }

constructor TStringObject.Create(AValue: string);
begin
  Value := AValue;
end;

function TStringObject.Inspect: string;
begin
  Result := Value;
end;

function TStringObject.ObjetcType: TEvalObjectType;
begin
  Result := STRING_OBJ;
end;

{ TBuiltinObject }

constructor TBuiltinObject.Create(ABuiltinFunction: TBuiltinFunction);
begin
  BuiltinFunction := ABuiltinFunction;
end;

function TBuiltinObject.Inspect: string;
begin
  Result := 'builtin function'
end;

function TBuiltinObject.ObjetcType: TEvalObjectType;
begin
  Result := BUILTIN_OBJ;
end;

/// --- builtin function

function FnLen(args: TList<TEvalObject>): TEvalObject;
begin
  if (args.Count<>1) then
    Result := newError('wrong number of arguments. got=%d, want=1', [args.Count])
  else
  begin
    if args[0].ObjetcType=STRING_OBJ then
      Result := TNumberObject.Create(Length(TStringObject(args[0]).Value))
    else
      Result := newError('argument to `len` not supported, got %s', [args[0].ObjetcType]);
  end;
end;

/// --- builtin function

procedure init;
begin
  builtins := TDictionary<string,TBuiltinObject>.Create;
  builtins.Add('len', TBuiltinObject.Create(FnLen));
//  _NULL_ := TNullObject.Create;
//  _TRUE_ := TBooleanObject.Create(True);
//  _FALSE_:= TBooleanObject.Create(False);
end;

procedure deinit;
begin
  builtins.Free;
//  FreeAndNil(_NULL_);
//  FreeAndNil(_TRUE_);
//  FreeAndNil(_FALSE_);
end;


initialization
  init;
finalization
  deinit;

end.

